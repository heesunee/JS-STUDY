24장 클로저

> 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합

이게 뭔 개소리다냐.

차근차근 알아가보자.

> 함수가 선언된 렉시컬 환경 => 그 함수의 상위 스코프

24.1 렉시컬 스코프
자바스크립트 엔진은 함수를 어디서 호출했는지가 아니라 함수를 어디에 정의했는지에 따라 상위 스코프를 결정한다.

스코프의 실체: 실행 컨텍스트의 렉시컬 환경

스코프 체인: 렉시컬 환경은 자신의 외부 렉시컬 환경에 대한 참조를 통해 상위 렉시컬 환경과 연결됨

외부 렉시컬 환경에 대한 참조 = 상위 렉시컬 환경에 대한 참조

=> 현재 실행 컨텍스트의 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값

렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값(상위 스코프에 대한 참조)는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다. 이것이 렉시컬 스코프다.

24.1 함수 객체의 내부 슬롯 [ [Environment] ]
정의된 위치와는 다른 곳에서 호출될 수 있기 때문에, 함수는 자신이 정의된 위치의 상위 스코프를 기억해야함

따라서 함수는 자신의 내부 슬롯 [ [Environment] ]에 자신이 정의된 환경, 상위 스코프의 참조를 저장한다.

함수가 정의되는 시점 -> 아직 그 함수의 실행컨텍스트가 아님, 상위의 실행 컨텍스트이기 때문의, 상위 스코프의 참조는 현재 실행중인 실행 컨텍스트의 렉시컬 환경을 가리키는 것임!

```js
const x = 1;

function foo() {
  const x = 10;

  // 상위 스코프는 함수가 정의된 위치에 따라 결정된다.
  // 함수 호출 위치와 상위 스코프는 관계 ❌
  bar();
}

// bar의 상위 스코프는 전역, 따라서 [[Environment]]에 전역 렉시컬 환경을 저장함
function bar() {
  console.log(x);
}

foo();
bar();
```

전역 코드의 평가 시점에

const x =1, foo() 함수, bar() 함수가 window에 저장되고, 이 시점에 foo()함수, bar() 함수의 [[Environment]]에 저장됨

foo(), bar() 함수를 실행하면서 상위 스코프로 이동해야할때, 여기서 이동할 외부 렉시컬 환경에 대한 참조는 [[Environment]]에 저장된 참조를 따라간다.

24.3 클로저와 렉시컬 환경

```js
const x = 1;

function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

// outer 함수를 호출하면 중첩 함수 inner를 반환
// outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop되어 제거된다.

const innerFunc = outer();
innerFunc();
```

innerFunc에 outer함수를 할당하는 outer 함수 호출시점에서 outer은 iiner를 반환하고 마감되어, outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거된다. 그런데 innerFunc()의 실행 결과는 x=10

외부 함수보다 중첩 함수가 더 오래 유지되는 경우 중첩함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있다. 이러한 중첩 함수를 클로저라 한다.

inner 함수는 자신이 평가될 때 이미 자신의 상위 스코프(inner가 선언된 렉시컬 환경)를 자신이 [[Environment]] 내부 슬롯에 저장되었다.

outer 함수의 실행 컨텍스트가 제거되어도 outer 함수의 렉시컬 환경이 유지되는 이유
outer 함수의 실행 컨텍스트가 실행 컨텍스트 스택에서 제거되었다고 해서, outer 함수의 렉시컬 환경까지 소멸은 ❌

inner 함수의 [[Environment]]에서 outer 함수의 렉시컬 환경을 참조하고 있고, inner 함수는 전역변수 innerFunc에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않는다.

자바스크립트의 모든 함수는 상위 스코프를 기억해 이론적으로 모든 함수가 클로저지만, 모든 함수를 클로저라고 하지는 않는다.

- 중첩 함수라 할지라도, 상위 스코프의 어떤 식별자도 참조하지 않는 경우 클로저가 아니다. (대부분의 모던 브라우저는 최적화를 통해 상위 스코프를 기억하지 않는다. 참조하지도 않는 식별자를 기억하는 것은 메모리 낭비)

- 중첩 함수 내부에서 상위 스코프의 식별자를 참조하더라도, 중첩함수의 생명주기가 외부함수보다 짧은 경우 클로저가 아니다.

클로저의 본질: 중첩 함수가 생명주기가 종료된 외부 함수의 식별자를 참조하는 것, 클로저는 중첩 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우에 한정한다.

자유 변수: 클로저에 의해 참조되는 상위 스코프의 변수 (foo 함수의 x 변수같은 것)

24.4 클로저의 활용
상태를 안전하게 은닉하고, 특정 함수에게만 상태 변경을 허용하면서 상태를 안전하게 변경하고 유지하기 위해 사용

```js
const increase = (function () {
  let num = 0;

  return function () {
    return ++num;
  };
})();

console.log(increase()); // 1
console.log(increase()); // 2
```

즉시 실행 함수가 호출되면서, 반환한 함수가 increase 변수에 할당된다. 리턴 함수는 정의됨과 동시의 즉시 실행 함수의 렉시컬 환경을 기억하는 클로저다. 즉시 실행 함수는 한번만 실행되므로 num이 재차 초기화 될 일은 없다.

클로저는 상태가 의도치 않게 변경되지 않도록 안전하게 은닉하고 특정 함수에게만 상태 변경을 허용하여 상태를 안정하게 변경하고 유지하기 위해 사용한다.

```js
// 카운트 상태를 유지하기 위한 자유 변수 counter를 기억하는 클로저를 반환한다.
function makeCounter(aux) {
// 카운트 상태를 유지하기 위한 자유 변수
let counter = 0;

// 클로저를 반환
return function() {
// 인수로 전달받은 보조 함수에 상태 변경을 넘긴다.
counter = aux(counter);
return counter;
};
}

function increase(n) {
return ++n;
}

function decrease(n) {
return --n;
{

// 함수로 함수를 생성한다.
cosnt increaser = makeCounter(increase);
console.log(increaser()); // 1
console.lpg(increaser()); // 2

// increaser 함수와는 별개의 독립된 렉시컬 환경을 갖기 때문에 카운터 상태가 연동하지 않는다.
const decreaser = makeCounter(decrease);
console.log(decreaser()); // -1
console.log(decreaser()); // -2
```

makeCounter 함수가 반환하는 함수는 자신이 생성됐을 때의 렉시컬 환경인 makeCounter 함수의 스코프에 속한 counter 변수를 기억하는 클로저다. 독립된 렉시컬 환경을 갖는다.

24.5 캡슐화와 정보 은닉 (여기 잘 모르겠음)
캡슐화: 프로퍼티와 메서드를 하나로 묶는 것 (정보 은닉)

자바스크립트는 접근 제한자가 없으므로 기본적으로 객체의 모든 프로퍼티와 메서드는 외부에 공개되어 있다.

24.6 자주 발생하는 실수

```js
var funcs = [];

for (var i = 0; i < 3; i++) {
  funcs[i] = function () {
    return i;
  }; // 1
}

for (var j = 0; j < funcs.length; j++) {
  console.log(funcs[j]()); // 2
}
```

i 변수는 함수 레벨 스코프를 갖기 때문에 전역 변수이고, 호출하면 i의 값 3이 출력된다.

클로저를 사용해 바꿔보자

```js
var funcs = [];

for (var i = 0; i < 3 ; i++){
funcs[i] = (function (id) {
return function () {
return id;
};
}(i);;
}

for (var j = 0; j < funcs.length; j++) {
console.log(funcs[j]());
}
```

즉시 실행 함수는 i에 할당되어 있는 값을 인수로 전달 받아 id에 할당 후 중첩함수를 반환하고 종료된다.

여기서 id는 즉시 실행 함수가 반환한 중첩 함수의 상위 스코프에 존재한다. id는 자유 변수가되어 그 값이 유지된다.

let이나 const 키워드를 사용하는 반복문은 코드 블록을 반복 실행할 때마다 새로운 렉시컬 환경을 생성하여 반복할 당시의 상태를 스냅샷 찍는 것처럼 저장한다. 반복문이 생성하는 새로운 렉시컬 환경은, 반복 직후 가비지 컬렉션의 대상이 된다.

var를 사용한 반복문을 해결하려면, 즉시 실행함수(클로저 만들기)나 let을 이용 또는 고차 함수를 사용한다.
